<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2 Player Race with Health Bars</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
    }

    canvas {
      display: block;
      background: linear-gradient(to top, #111, #222);
    }

    #winMessage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      color: white;
      background: rgba(0,0,0,0.6);
      padding: 1rem 2rem;
      border-radius: 10px;
      display: none;
      z-index: 999;
    }
  </style>
</head>
<body>
  <div id="winMessage"></div>
  <canvas id="gameCanvas" width="900" height="600"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const FINISH_LINE = 40;
    const PLAYER_RADIUS = 25;
    const OBSTACLE_WIDTH = 30;
    const OBSTACLE_HEIGHT = 30;
    const OBSTACLE_SPEED = 6;
    const MAX_HEALTH = 100;
    const DAMAGE = 25;

    const keys = {};

    document.addEventListener('keydown', (e) => {
      keys[e.key] = true;
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    const players = {
      left: {
        x: canvas.width / 3,
        y: canvas.height - 60,
        color: 'cyan',
        keys: { left: 'a', right: 'd', up: 'w' },
        health: MAX_HEALTH,
        width: PLAYER_RADIUS * 2,
        height: PLAYER_RADIUS * 2,
        hitCooldown: 0
      },
      right: {
        x: (canvas.width * 2) / 3,
        y: canvas.height - 60,
        color: 'orange',
        keys: { left: 'ArrowLeft', right: 'ArrowRight', up: 'ArrowUp' },
        health: MAX_HEALTH,
        width: PLAYER_RADIUS * 2,
        height: PLAYER_RADIUS * 2,
        hitCooldown: 0
      }
    };

    const obstacles = [];

    function spawnObstacle() {
      const isLeft = Math.random() > 0.5;
      const sideX = isLeft ? canvas.width / 3 : (canvas.width * 2) / 3;
      const offset = (Math.random() - 0.5) * 100;

      obstacles.push({
        x: sideX + offset,
        y: -30,
        width: OBSTACLE_WIDTH,
        height: OBSTACLE_HEIGHT,
        color: 'red',
        side: isLeft ? 'left' : 'right'
      });
    }

    function drawPlayer(player) {
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.arc(player.x, player.y, PLAYER_RADIUS, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(player.x - 8, player.y - 5, 3, 0, Math.PI * 2);
      ctx.arc(player.x + 8, player.y - 5, 3, 0, Math.PI * 2);
      ctx.fill();

      // Health bar
      const barWidth = 60;
      const barHeight = 8;
      const barX = player.x - barWidth / 2;
      const barY = player.y - PLAYER_RADIUS - 20;

      ctx.fillStyle = 'gray';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      ctx.fillStyle = 'limegreen';
      ctx.fillRect(barX, barY, (player.health / MAX_HEALTH) * barWidth, barHeight);
      ctx.strokeStyle = 'white';
      ctx.strokeRect(barX, barY, barWidth, barHeight);
    }

    function updatePlayer(player, keyMap) {
      if (keys[keyMap.left] && player.x > PLAYER_RADIUS + 10) {
        player.x -= 4;
      }
      if (keys[keyMap.right] && player.x < canvas.width - PLAYER_RADIUS - 10) {
        player.x += 4;
      }
      if (keys[keyMap.up] && player.y > 10) {
        player.y -= 3;
      }
    }

    function drawObstacle(ob) {
      ctx.fillStyle = ob.color;
      ctx.fillRect(ob.x - ob.width / 2, ob.y, ob.width, ob.height);
    }

    function checkCollision(player, ob) {
      const px = player.x;
      const py = player.y;
      const pw = PLAYER_RADIUS;
      const ph = PLAYER_RADIUS;

      return (
        px + pw > ob.x - ob.width / 2 &&
        px - pw < ob.x + ob.width / 2 &&
        py + ph > ob.y &&
        py - ph < ob.y + ob.height
      );
    }

    function drawFinishLine() {
      ctx.fillStyle = 'white';
      ctx.fillRect(0, FINISH_LINE, canvas.width, 4);
    }

    function showWinner(text) {
      const msg = document.getElementById('winMessage');
      msg.textContent = text;
      msg.style.display = 'block';
      cancelAnimationFrame(animationId);
    }

    let frame = 0;
    let animationId;

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawFinishLine();

      // Update players
      updatePlayer(players.left, players.left.keys);
      updatePlayer(players.right, players.right.keys);

      drawPlayer(players.left);
      drawPlayer(players.right);

      // Spawn obstacles
      if (frame % 50 === 0) {
        spawnObstacle();
      }

      // Update obstacles
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const ob = obstacles[i];
        ob.y += OBSTACLE_SPEED;
        drawObstacle(ob);

        if (ob.y > canvas.height) {
          obstacles.splice(i, 1);
          continue;
        }

        // Collisions
        const p = ob.side === 'left' ? players.left : players.right;

        if (checkCollision(p, ob)) {
          if (p.hitCooldown === 0) {
            p.health -= DAMAGE;
            p.hitCooldown = 30; // cooldown frames
          }
        }
      }

      // Handle cooldowns
      for (const key in players) {
        if (players[key].hitCooldown > 0) {
          players[key].hitCooldown--;
        }
      }

      // Win conditions
      if (players.left.health <= 0) return showWinner("Right Player Wins (Left died)");
      if (players.right.health <= 0) return showWinner("Left Player Wins (Right died)");
      if (players.left.y <= FINISH_LINE) return showWinner("Left Player Wins!");
      if (players.right.y <= FINISH_LINE) return showWinner("Right Player Wins!");

      frame++;
      animationId = requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>

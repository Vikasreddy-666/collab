<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2 Player Vertical Obstacle Race</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }

    canvas {
      display: block;
      background: linear-gradient(to top, #111, #333);
    }

    #winMessage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 2rem;
      z-index: 10;
      display: none;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="winMessage"></div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const finishLine = 50;
    const gravity = 0.8;
    const moveSpeed = 4;
    const jumpPower = -12;
    const obstacleSpeed = 5;
    const playerSize = 40;

    const players = {
      left: {
        x: canvas.width / 4,
        y: canvas.height - 60,
        vy: 0,
        width: playerSize,
        height: playerSize,
        color: 'cyan',
        crouching: false,
        keys: {
          left: 'a', right: 'd',
          up: 'w', jump: 'q', crouch: 'e'
        }
      },
      right: {
        x: (canvas.width * 3) / 4,
        y: canvas.height - 60,
        vy: 0,
        width: playerSize,
        height: playerSize,
        color: 'orange',
        crouching: false,
        keys: {
          left: 'ArrowLeft', right: 'ArrowRight',
          up: 'ArrowUp', jump: 'Shift', crouch: 'Control'
        }
      }
    };

    const keysPressed = {};
    const obstacles = [];

    document.addEventListener('keydown', (e) => {
      keysPressed[e.key] = true;
    });

    document.addEventListener('keyup', (e) => {
      keysPressed[e.key] = false;
    });

    function drawPlayer(player) {
      ctx.beginPath();
      ctx.fillStyle = player.color;
      ctx.arc(player.x, player.y, player.width / 2, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(player.x - 8, player.y - 5, 3, 0, Math.PI * 2);
      ctx.arc(player.x + 8, player.y - 5, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    function updatePlayer(player) {
      if (keysPressed[player.keys.left] && player.x - player.width / 2 > 0) {
        player.x -= moveSpeed;
      }
      if (keysPressed[player.keys.right] && player.x + player.width / 2 < canvas.width) {
        player.x += moveSpeed;
      }

      // Move up to finish line
      if (keysPressed[player.keys.up]) {
        player.y -= moveSpeed;
      }

      // Jump (adds Y velocity)
      if (keysPressed[player.keys.jump] && player.vy === 0) {
        player.vy = jumpPower;
      }

      // Crouch (reduce size)
      if (keysPressed[player.keys.crouch]) {
        player.crouching = true;
        player.height = playerSize / 2;
      } else {
        player.crouching = false;
        player.height = playerSize;
      }

      // Apply gravity
      player.vy += gravity;
      player.y += player.vy;

      // Stay on ground
      if (player.y > canvas.height - 60) {
        player.y = canvas.height - 60;
        player.vy = 0;
      }

      // Clamp to top
      if (player.y < 10) {
        player.y = 10;
      }
    }

    function spawnObstacle() {
      const side = Math.random() > 0.5 ? 'left' : 'right';
      const x = side === 'left' ? canvas.width / 4 : (canvas.width * 3) / 4;
      const offset = (Math.random() - 0.5) * 100;

      obstacles.push({
        x: x + offset,
        y: -30,
        width: 30,
        height: 30,
        color: 'red',
        side: side
      });
    }

    function drawObstacle(obs) {
      ctx.fillStyle = obs.color;
      ctx.fillRect(obs.x - obs.width / 2, obs.y, obs.width, obs.height);
    }

    function checkCollision(player, obs) {
      return (
        player.x + player.width / 2 > obs.x - obs.width / 2 &&
        player.x - player.width / 2 < obs.x + obs.width / 2 &&
        player.y + player.height / 2 > obs.y &&
        player.y - player.height / 2 < obs.y + obs.height
      );
    }

    function showWinner(winner) {
      const msg = document.getElementById("winMessage");
      msg.textContent = `${winner} Player Wins!`;
      msg.style.display = 'block';
      cancelAnimationFrame(gameLoopId);
    }

    function drawFinishLine() {
      ctx.fillStyle = 'white';
      ctx.fillRect(0, finishLine, canvas.width, 4);
    }

    let frameCount = 0;
    let gameLoopId;

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawFinishLine();

      updatePlayer(players.left);
      updatePlayer(players.right);

      drawPlayer(players.left);
      drawPlayer(players.right);

      if (frameCount % 50 === 0) {
        spawnObstacle();
      }

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.y += obstacleSpeed;
        drawObstacle(obs);

        if (obs.y > canvas.height + 30) {
          obstacles.splice(i, 1);
        }

        if (obs.side === 'left' && checkCollision(players.left, obs)) {
          // Knockback
          players.left.y += 30;
        }

        if (obs.side === 'right' && checkCollision(players.right, obs)) {
          // Knockback
          players.right.y += 30;
        }
      }

      // Win check
      if (players.left.y <= finishLine) {
        showWinner("Left");
      } else if (players.right.y <= finishLine) {
        showWinner("Right");
      } else {
        frameCount++;
        gameLoopId = requestAnimationFrame(gameLoop);
      }
    }

    gameLoop();
  </script>
</body>
</html>
